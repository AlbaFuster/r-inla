---
title: "SPDE example with multiple kind of outcomes:"
subtitle: "Joint modeling with `mdata`, `inla.surv` and counts with exposure."
author: "Elias T Krainski"
date: "2023, March"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{SPDE example with multiple kind of outcomes.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: spdeshort.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  dev.args = list(type = "cairo-png"),
  fig.width = 10,
  fig.height = 7, 
  out.width = "99%"
)
knitr::opts_chunk$set(echo = TRUE)
```

# Abstract 

The **INLA** package support different kind of likelihood data,
including the `inla.surv`, which is a generalization of the
`Surv` from the **survival** package, and `mdata`.
In this vignette we illustrate the case when we have
three correlated outcomes, one of each type.
The correlation is induced from having these outcomes
sharing the same covariate and random effect.
The random effect is modeled using the SPDE approach.

# Introduction 

We want to illustrate how to jointly model different data kind of outcomes
when there is a term in the model being modeled using the SPDE approach.
Therefore, we consider three outcomes being measured on a spatial domain.
These outcomes are correlated because the linear predictor of each one
contains common fixed and random effect. 

We consider a scenario where the first outcome is known at an aggregated level,
in a setting were we model it considering a kind of likelihood designed in
**INLA** to account for all the information available with respect to the aggregation.
The second outcome is considered to be observed censored,
so that we have to consider the observed value and the censoring information.
The third outcome is just the usual kind of data: one scalar per data unit.

## The spatial domain 

We consider a spatial domain, $D \in \mathbb{R}^2$.
The assumption of $\mathbb{R}^2$ is just to keep the example
reasonable simple.
However, the SPDE models available in **INLA**
could be applied for processes in $\mathbb{R}^d$
or $\mathbb{S}^d$, for $d=1,2$, see @lindgrenRL2011.
Without loss off generality we consider a
simple rectangle to be the defined as
```{r domain}
bb <- rbind(c(0, 20), c(0, 12))
```

We will also consider the length of each side and its average for later use
```{r rxy}
rxy <- apply(bb, 1, diff)
b <- mean(rxy)
```

Let now define a smooth function on this domain to be considered as a
spatial effect. 
```{r sfn}
sfn <- function(a, b)
    sin(a + b) + cos(a - b)
```

Let now consider a set of $n$ locations, 
$l_1, ..., l_n$, in this domain, $l_i \in D$, as follows:
```{r loc}
set.seed(1)
n <- 500
loc <- cbind(
    runif(n, bb[1, 1], bb[1, 2]),
    runif(n, bb[2, 1], bb[2, 2]))
```

## A spatial field

We now evaluate the smooth function at these locations, 
and visualize it
```{r sloc}
u <- sfn(2 * pi * loc[, 1] / rxy[1],
         2 * pi * loc[, 2] / rxy[2])
summary(u)
par(mar = c(2, 2, 0, 0), mgp = c(1.5, 0.5, 0), las = 1)
plot(loc, pch = 19, cex = 0.5 + (2 + u)/4, xlab = "", ylab = "")
```

## Spatial sub-domains 

Let us consider that the domain is being divided into a set of sub-regions, 
define a set of small sub-regions over this domain, 
$r_1, r_2, ..., r_g$, 
so that $r_i \cap r_i = \oslash$ and $\cup_{i=1}^g r_j = D$.

For simplicity of coding, but without loss of generality,
we assume that these small sub-regions are made up of small pixels.
This is just to avoid the need of dealing with the general
spatial objects and operations available in **R**.

Let the following set of centers:
```{r centers}
h <- 2 ## size of the side of each sub-region
group.ce <- as.matrix(expand.grid(
    seq(bb[1, 1] + h/2, bb[1, 2], h),
    seq(bb[2, 1] + h/2, bb[2, 2], h)))
(ng <- nrow(group.ce))
```

We now identify each location $l_i$ to each sub-region $r_j$
with an integer vector.
```{r groupid}
group.id <- ceiling(loc[,1]/h)+ceiling(rxy[1]/h) *
  (ceiling(loc[,2]/h)-1)
```

We will visualize the locations by colour depending on this grouping later.

## Covariates

Let us consider a set of three covariates
for each location as 
```{r xxx}
xxx <- cbind(x1 = runif(n), x2 = runif(n), x3 = runif(n))
```

# Outcomes

We will consider three outcomes.

### First outcome: aggregated Gaussian

We assume that one of the outcomes is a continuous random variable,
to be considered as Gaussian, with unknown mean and variance,
and a scaling factor, $s$, such that 
\[ 
y_i \sim \textrm{N}(\mu_i, s_i\sigma^2).
\]

We will simulate the scaling factor for each observation with
```{r s}
s <- rgamma(n, 7, 3)
summary(s)
```

The first outcome being simulated considering that the
expected value as $\eta_1 = \{\mu_1, ..., \mu_n\}$ as
\[ 
\eta_1 = \mathbf{X}\beta_1 + \mathbf{u}
\]
with
```{r y}
betas1 <- c(5, 0, -3, 3) 
sigma.y <- 1
mu.y <- cbind(1, xxx) %*% betas1 + u
y <- rnorm(n, mu.y, sqrt(sigma.y/s))
summary(y)
```

However, we consider that observations of this variable were
being observed as aggregated over each of the small sub-regions $r_j$.
Furthermore, for each sub-region $r_j$, we know 

 - how many observations were taken in each sub-region, $n_j = \sum_{i=1}^n I(l_i \in r_j)$
 - the weighted average $\overline{y}_j$ = $(n_j)^{-1}\sum_{i,l_i\in r_j} s_iy_i$,
 - the sum o the scaling factors, $m_j$ = $\sum_{i,l_i\in r_j} s_i$, 
 - the half of the sum of the log of the scaling factors, $\frac{1}{2}\sum_{i,l_i\in r_j} \log(s_i)$,
 - and the sample variance within each unit, defined as
 $v_j$ = $\frac{1}{n_j}\sum_{i,l_i\in r_j}^n(s_i y_i^2-\overline{y}_j^2)$

The function `inla.agaussian` computes these five statistics, 
given $y_i$ and $s_i$ in each group. 
We use this function to compute these statistics, 
as the aggregated data for each sub-region, as follows 
```{r ag, warning}
library(INLA)
agg <- lapply(1:ng, function(g) {
    ig <- which(group.id==g)
    if(length(ig)>0) 
        return(inla.agaussian(y[ig], s[ig]))
    return(inla.mdata(list(NA, 0, 1, 1, NA))) ### a deal with missing
})
str(YY <- Reduce('rbind', lapply(agg, unlist))) ## five columns matrix
```

We will do average of the covariates by group as well as we will consider that
we only have data at the group level to model this first outcome.
```{r x.g}
xxx.g <- aggregate(xxx, list(g = group.id), mean)
str(xxx.g)
```

## Second outcome: Survival

One can fit survival modes using **INLA** considering several available 
likelihoods. One is the `weibullsurv` and we will now consider
that we have an outcome that follows a Weibull distribution, 
considering the following parametrization
\[
f_W(w) = \alpha w^{\alpha - 1} \lambda^\alpha \textrm{e}^{-(\lambda w)^\alpha}.
\]
We assume that $\lambda = \exp(\eta_2)$, 
where $\eta_2$ is the linear predictor and is defined as
\[ 
\eta_2 = \mathbf{X}\beta + \gamma_1\mathbf{u}
\]
and we consider the following code to sample from a Weibull distribution
```{r w0}
betas2 <- c(1, -1, 0, 1)
alpha <- 2
gamma1 <- 0.5
lambdaw <- exp(cbind(1, xxx) %*% betas2 + gamma1 * u)
we0 <- rweibull(n, shape = alpha, scale = 1/lambdaw)
summary(we0)
```

However, suppose we do not observe the survival times for some of the observations.
```{r event}
summary(u.ev <- runif(n, 0.3, 1)) ## censoring factor
table(event <- rbinom(n, 1, 0.5)) ## censored (=0) or event (=1)
summary(we <- ifelse(event == 1, we0, we0 * u.ev)) ## censored outcome
```

## Third outcome: Count under exposure

We consider that we have different exposure at each location
```{r ee}
summary(ee <- rgamma(n, 10, 2))
``` 

We assume an outcome following a Poisson distribution with 
\[ 
o_i \sim \textrm{Poisson}(\lambda_i E_i)
\]
where $\lambda_i$ depends on the covariates and assuming that 
\[
\log{\lambda} = \eta_3 = \mathbf{X}\beta_e + \gamma_2\mathbf{u}
\]

This outcome is being simulated with
```{r po}
betas3 <- c(2, 1, -1, 0)
gamma2 <- -0.3
lambdap <- cbind(1, xxx) %*% betas3 + gamma2 * u
po <- rpois(n, exp(lambdap) * ee)
summary(po)
```

# Data model setup 

We now have to setup the objects in order to fit the model.

## SPDE model setup

We have to define a mesh over the domain. 
We do it considering the following code
```{r mesh}
mesh <- inla.mesh.2d(
    loc.domain = matrix(bb[c(1,3,3,1,1, 2,2,4,4,2)], ncol = 2), 
    max.edge = c(.05, .15) * b,
    offset = c(.1, .2) * b)
```

This mesh and the locations colored by the group defined for the first
outcome can be visualized with
```{r vmesh}
par(mar = c(0, 0, 1, 0), mgp = c(1.5, 0.5, 0))
plot(mesh, asp = 1, edge.color = gray(0.5))
points(loc, pch = 19, col = group.id, cex = 0.3 + (2 + u)/4)
```

The SPDE model is defined with
```{r spde}
spde <- inla.spde2.pcmatern(
    mesh,
    prior.range=c(1, 0.1),
    prior.sigma=c(1, 0.1))
```

## Linear predictor components

We will fit a joint model considering the linear predictor
with terms as how it was simulated.
One way to deal with multiple likelihoods is to
use list in the left hand side of the `formula`. 

The left rand side will include each term in the linear predictor,
where we will have an intercept for each outcome,
one effect for each covariate for each outcome,
the SPDE model for the first outcome,
and one copy from this random effect
for each of the other two outcomes.

That is we can define the model formula as
```{r formula}
fff <- list(
  inla.mdata(Y),
  inla.surv(w, ev),
  o) ~ 0 +
  a1 + x1y + x2y + x3y + f(s, model = spde) +
  a2 + x1w + x2w + x3w + f(sc1, copy = "s", fixed = FALSE) +
  a3 + x1p + x2p + x3p + f(sc2, copy = "s", fixed = FALSE)
```


## Data stacks

The data has to be organized so it contains all the information needed.
We need to supply the five column matrix with the five statistics
for each of the `ng` groups defined for the first outcome,
Two vectors to build the `inla.surv` data for the second outcome. 
Two vectors to build the count and exposure for the third outcome.

The easier way is to define a data stack for each outcome separated and
them join them all.

The stack for the first outcome
```{r stack1}
stackY <- inla.stack(
    tag = 'y',
    data = list(Y = YY),
    effects= list(
        data.frame(a1 = 1,
                   x1y = xxx.g$x1, 
                   x2y = xxx.g$x2, 
                   x3y = xxx.g$x3),
        s = 1:mesh$n),
    A=list(1,
           inla.spde.make.A(mesh, group.ce))
)
```

The stack for the second outcome
```{r stack2}
stackW <- inla.stack(
    tag = 'w', 
    data = list(w = we,
                ev = event), 
    effects = list(
        data.frame(a2 = 1,
                   x1w = xxx[, 1], 
                   x2w = xxx[, 2], 
                   x3w = xxx[, 3]),
        sc1 = 1:mesh$n),
    A = list(1,
             inla.spde.make.A(mesh, loc))
)
```

The stack for the third outcome
```{r stack3}
stackP <- inla.stack(
    tag = 'p', 
    data = list(o = po,
                E = ee),
    effects = list(
        data.frame(a3 = 1,
                   x1p = xxx[, 1], 
                   x2p = xxx[, 2], 
                   x3p = xxx[, 3]),
        sc2 = 1:mesh$n),
    A = list(1,
             inla.spde.make.A(mesh, loc))
)
```

Joining all the data into one data stack
```{r jstack}
stacked <- inla.stack(stackY, stackW, stackP)
```

# Fitting the model

We now supply this to the `inla()` function in order to fit the model
```{r fit}
result <- inla(
   formula = fff,
    family = c("agaussian", "weibullsurv", "poisson"),
    data = inla.stack.data(stacked),
    E = E, 
    control.predictor = list(
        A=inla.stack.A(stacked)),
    control.family = list(
        list(),
        list(variant = 1),
        list())
)
result$cpu
```

We now compare the true value for each 
fixed effect with its posterior summary.

```{r fixef}
round(cbind(
    true = c(betas1, betas2, betas3),
    result$summary.fix), 2)
```

For the hyper-parameters, we do have fitted one for the
`agaussian` likelihood, 
one for the `weibulsuv` and we have those for the 
SPDE model assumed for the spatial smooth effect 
(defined from the sine and cosine functions)
and the fitted parameters for this term shared 
from the first to the second and third outcomes.

```{r hpars}
round(cbind(true = c(1/sigma.y^2, alpha, NA, NA, gamma1, gamma2), 
            result$summary.hy), 2)

```

# References
